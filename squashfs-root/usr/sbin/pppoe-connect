#!/bin/sh
# ../scripts/pppoe-connect.  Generated from pppoe-connect.in by configure.
#***********************************************************************
#
# pppoe-connect
#
# Shell script to connect to a PPPoE provider
#
# Copyright (C) 2000 Roaring Penguin Software Inc.
#
# $Id: pppoe-connect.cig,v 1.1 2010-07-08 12:44:52 rflu Exp $
#
# This file may be distributed under the terms of the GNU General
# Public License.
#
# LIC: GPL
#
# Usage: pppoe-connect [config_file]
#        pppoe-connect interface user [config_file]
# Second form overrides USER and ETH from config file.
# If config_file is omitted, defaults to /etc//ppp/pppoe.conf
#
#***********************************************************************

# From AUTOCONF
prefix=/usr
exec_prefix=${prefix}
localstatedir=/var

# Paths to programs
IFCONFIG=/sbin/ifconfig
PPPD=/usr/sbin/pppd
SETSID=""
PPPOE=/usr/sbin/pppoe
LOGGER="/usr/bin/logger -t `basename $0`"


# Set to "C" locale so we can parse messages from commands
LANG=C
export LANG

# Must be root
if test "`/usr/bin/id -u`" != 0 ; then
    echo "$0: You must be root to run this script" >& 2
    exit 1
fi

USER=""
ETH=""
XUNIT=$1
CONFIG=/tmp/ppp/pppoe${XUNIT}.conf
LOCK_FILE="/tmp/ppp/pppoe.lock"

if test ! -f "$CONFIG" -o ! -r "$CONFIG" ; then
    echo "$0: Cannot read configuration file '$CONFIG'" >& 2
    exit 1
fi
export CONFIG
. $CONFIG

PPPOE_CONNECT_PIDFILE="$PIDFILE.pppoe-connect"
PPPOE_PIDFILE="$PIDFILE.pppoe"
PPPD_PIDFILE="$PIDFILE.pppd"

# Check that config file is sane
if test "$USER" = "" ; then
    echo "$0: Check '$CONFIG' -- no setting for USER" >& 2
    exit 1
fi
if test "$ETH" = "" ; then
    echo "$0: Check '$CONFIG' -- no setting for ETH" >& 2
    exit 1
fi

PPPD_PID=0

# MTU of Ethernet card attached to modem MUST be 1500.  This apparently
# fails on some *BSD's, so we'll only do it under Linux
#$IFCONFIG $ETH up mtu 1530

if test "$SYNCHRONOUS" = "yes" ; then
    PPPOE_SYNC=-s
    PPPD_SYNC=sync
	# Increase the chances of it working on Linux...
    if test `uname -s` = Linux ; then
	modprobe n_hdlc > /dev/null 2>&1
    fi
else
    PPPOE_SYNC=""
    PPPD_SYNC=""
fi

if test -n "$ACNAME" ; then
    ACNAME="-C $ACNAME"
fi

if test -n "$SERVICENAME" ; then
    SERVICENAMEOPT="-S $SERVICENAME"
else
    SERVICENAMEOPT=""
fi

if test "$CLAMPMSS" = "no" ; then
    CLAMPMSS=""
else
    CLAMPMSS="-m $CLAMPMSS"
fi

# If DNSTYPE is SERVER, we must use "usepeerdns" option to pppd.
if test "$DNSTYPE" = "SERVER" ; then
    PEERDNS=yes
    USEPEERDNS=yes
fi

if test "$PEERDNS" = "yes" ; then
    PEERDNS="usepeerdns"
else
    PEERDNS=""
fi

# Backward config file compatibility -- PEERDNS used to be USEPEERDNS
if test "$USEPEERDNS" = "yes" ; then
    PEERDNS="usepeerdns"
fi
if test "$USEPEERDNS" = "no" ; then
    PEERDNS=""
fi


# Backward config file compatibility
if test "$DEMAND" = "" ; then
    DEMAND=no
fi

if test "$DEMAND" = "no" ; then
    DEMAND=""
else
#    DEMAND="idle $DEMAND"
    DEMAND="demand persist idle $DEMAND 10.112.112.112:10.112.112.113 ipcp-accept-remote ipcp-accept-local ktune"
fi

if test "$DEFAULTROUTE" != "no" ; then
    DEFAULTROUTE="defaultroute"
else
    DEFAULTROUTE=""
fi

if test "$MTU_MODE" = "1" ; then
    MTU_MRU="mtu $MTU_SIZE mru $MTU_SIZE"
else
    MTU_MRU=""
fi

# Standard PPP options we always use
PLUGIN_OPTS="plugin $LINUX_PLUGIN $ETH"
PPP_STD_OPTIONS="$PLUGIN_OPTS noccp noipdefault noauth default-asyncmap $DEFAULTROUTE hide-password nodetach $PEERDNS $MTU_MRU noaccomp nodeflate nopcomp novj novjccomp user $USER lcp-echo-interval $LCP_INTERVAL lcp-echo-failure $LCP_FAILURE $PPPD_EXTRA unit $UNIT"

# Jigger DNS if required...
#if test "$DNSTYPE" = "SERVER" ; then
    # Sorry, dude...
#    rm -f /etc/resolv.conf
#    ln -s /etc/ppp/resolv.conf /etc/resolv.conf
#elif test "$DNSTYPE" = "SPECIFY" ; then
    # Sorry, dude...
#    rm -f /etc/resolv.conf
#    echo "nameserver $DNS1" > /etc/resolv.conf
#    if test -n "$DNS2" ; then
#	echo "nameserver $DNS2" >> /etc/resolv.conf
#    fi
#fi

# PPPoE invocation, discovery timeout is all the same
PPPOE_CMD="$PPPOE -p $PPPOE_PIDFILE -I $ETH -T $PPPOE_TIMEOUT -B -U $PPPOE_SYNC $CLAMPMSS $ACNAME $SERVICENAMEOPT $PPPOE_EXTRA"
echo $$ > $PPPOE_CONNECT_PIDFILE


# max=$RETRY_TIMES
# for i in $(seq $max); do
while [ true ] ; do

    while [ -f ${LOCK_FILE} ] ; do
    	sleep 1
    done

    echo "1" > ${LOCK_FILE}
    ln -sf /tmp/ppp/chap-secrets${XUNIT} /tmp/ppp/chap-secrets
    ln -sf /tmp/ppp/chap-secrets${XUNIT} /tmp/ppp/pap-secrets

    if test "$OVERRIDE_PPPD_COMMAND" != "" ; then
	$SETSID $OVERRIDE_PPPD_COMMAND &
	echo "$!" > $PPPD_PIDFILE
    elif test "$LINUX_PLUGIN" != "" ; then
	$SETSID $PPPD $PPP_STD_OPTIONS $DEMAND &
	echo "$!" > $PPPD_PIDFILE
    else
	$SETSID $PPPD pty "$PPPOE_CMD" \
	    $PPP_STD_OPTIONS \
	    $DEMAND \
	    $PPPD_SYNC &
	echo "$!" > $PPPD_PIDFILE
    fi
    wait

    kill -9 `cat $PPPOE_PIDFILE`

    rm -rf ${LOCK_FILE}

    if test "$RETRY_ON_FAILURE" = "no" -o "$DEMAND" != "" ; then
	exit
    fi

    # Run /etc/ppp/pppoe-lost if it exists
    test -x /etc/ppp/pppoe-lost && /etc/ppp/pppoe-lost

    # Re-establish the connection
    #$LOGGER -p daemon.notice \
    #    "PPPoE connection lost; attempting re-connection."

    # Wait a bit in case a problem causes tons of log messages :-)
    sleep $CONNECT_TIMEOUT
done
